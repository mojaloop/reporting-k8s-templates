apiVersion: mojaloop.io/v1
kind: MojaloopReport
metadata:
  name: reporting-bilateral-settlements-external-participants
spec:
  endpoint:
    params:
      - name: settlementId
        required: true
    path: /reporting-bilateral-settlements-external-participants
  permission: transferApi
  queries:
    - name: settlementInfoResult
      query: >
        SELECT
            s.settlementId,
            s.createdDate,
            ssc.settlementStateId as currentState,
            ssc.createdDate as lastStateUpdate,
            sSW.createdDate as windowCreatedDate,
            sSW.settlementWindowId,
            MIN(sWSCOpen.createdDate) as windowOpenDate,
            MAX(sWSCClosed.createdDate) as windowClosedDate
        FROM settlement s
        INNER JOIN settlementSettlementWindow sSW
                on s.settlementId = sSW.settlementId
        INNER JOIN settlementWindowStateChange sWSCOpen
                on sSW.settlementWindowId = sWSCOpen.settlementWindowId AND sWSCOpen.settlementWindowStateId = 'OPEN'
        INNER JOIN settlementWindowStateChange sWSCClosed
                on sSW.settlementWindowId = sWSCClosed.settlementWindowId AND sWSCClosed.settlementWindowStateId = 'CLOSED'
        INNER JOIN settlementStateChange ssc
            on s.currentStateChangeId = ssc.settlementStateChangeId
        WHERE s.settlementId = :settlementId
        GROUP BY s.settlementId, sSW.settlementWindowId;
    - name: settlementParticipantCurrencyIdsResult
      query: >
        SELECT
            result1.participantCurrencyId as debtorParticipantCurrencyId,
            result2.participantCurrencyId as creditorParticipantCurrencyId,
            SUM(result1.amount) as debtorTotalAmount,
            SUM(result2.amount) as creditorTotalAmount
        FROM

        (SELECT
            pc.participantCurrencyId,
            unioned.transferId,
            unioned.uniqueLegId,
            SUM(unioned.change) as amount
        FROM (
            SELECT
                ppc.participantCurrencyId,
                ppc.change,
                tf.settlementWindowId,
                tf.transferId AS transferId,
                tf.transferId AS uniqueLegId
            FROM
                transferFulfilment AS tf
            INNER JOIN
                transferStateChange AS tsc
                ON tsc.transferId = tf.transferId
            INNER JOIN
                participantPositionChange AS ppc
                ON ppc.transferStateChangeId = tsc.transferStateChangeId
            INNER JOIN
                settlementParticipantCurrency AS spc
                ON ppc.participantCurrencyId = spc.participantCurrencyId AND spc.settlementId = :settlementId
            INNER JOIN
                settlementSettlementWindow ssw
                ON tf.settlementWindowId = ssw.settlementWindowId AND ssw.settlementId = :settlementId

            UNION ALL

            SELECT
                ppc.participantCurrencyId,
                ppc.change,
                fxtf.settlementWindowId,
                fxt1.determiningTransferId AS transferId,
                fxt1.commitRequestId AS uniqueLegId
            FROM
                fxTransferFulfilment AS fxtf
            INNER JOIN
                fxTransfer AS fxt1
                ON fxt1.commitRequestId = fxtf.commitRequestId
            INNER JOIN
                fxTransferStateChange AS fxtsc
                ON fxtsc.commitRequestId = fxtf.commitRequestId
            INNER JOIN
                participantPositionChange AS ppc
                ON ppc.fxTransferStateChangeId = fxtsc.fxTransferStateChangeId
            INNER JOIN
                settlementParticipantCurrency AS spc
                ON ppc.participantCurrencyId = spc.participantCurrencyId AND spc.settlementId = :settlementId
            INNER JOIN
                settlementSettlementWindow ssw
                ON fxtf.settlementWindowId = ssw.settlementWindowId AND ssw.settlementId = :settlementId
        ) AS unioned
        INNER JOIN
            participantCurrency AS pc
            ON pc.participantCurrencyId = unioned.participantCurrencyId
        WHERE unioned.change > 0
        GROUP BY
            pc.participantCurrencyId,
            unioned.transferId,
            unioned.uniqueLegId
        ORDER BY unioned.transferId
        ) as result1

        INNER JOIN

        (SELECT
            pc.participantCurrencyId,
            unioned.transferId,
            unioned.uniqueLegId,
            SUM(unioned.change) as amount
        FROM (
            SELECT
                ppc.participantCurrencyId,
                ppc.change,
                tf.settlementWindowId,
                tf.transferId AS transferId,
                tf.transferId AS uniqueLegId
            FROM
                transferFulfilment AS tf
            INNER JOIN
                transferStateChange AS tsc
                ON tsc.transferId = tf.transferId
            INNER JOIN
                participantPositionChange AS ppc
                ON ppc.transferStateChangeId = tsc.transferStateChangeId
            INNER JOIN
                settlementParticipantCurrency AS spc
                ON ppc.participantCurrencyId = spc.participantCurrencyId AND spc.settlementId = :settlementId
            INNER JOIN
                settlementSettlementWindow ssw
                ON tf.settlementWindowId = ssw.settlementWindowId AND ssw.settlementId = :settlementId

            UNION ALL

            SELECT
                ppc.participantCurrencyId,
                ppc.change,
                fxtf.settlementWindowId,
                fxt1.determiningTransferId AS transferId,
                fxt1.commitRequestId AS uniqueLegId
            FROM
                fxTransferFulfilment AS fxtf
            INNER JOIN
                fxTransfer AS fxt1
                ON fxt1.commitRequestId = fxtf.commitRequestId
            INNER JOIN
                fxTransferStateChange AS fxtsc
                ON fxtsc.commitRequestId = fxtf.commitRequestId
            INNER JOIN
                participantPositionChange AS ppc
                ON ppc.fxTransferStateChangeId = fxtsc.fxTransferStateChangeId
            INNER JOIN
                settlementParticipantCurrency AS spc
                ON ppc.participantCurrencyId = spc.participantCurrencyId AND spc.settlementId = :settlementId
            INNER JOIN
                settlementSettlementWindow ssw
                ON fxtf.settlementWindowId = ssw.settlementWindowId AND ssw.settlementId = :settlementId
        ) AS unioned
        INNER JOIN
            participantCurrency AS pc
            ON pc.participantCurrencyId = unioned.participantCurrencyId
        WHERE unioned.change < 0
        GROUP BY
            pc.participantCurrencyId,
            unioned.transferId,
            unioned.uniqueLegId
        ORDER BY unioned.transferId
        ) as result2

        ON result1.transferId = result2.transferId AND result1.uniqueLegId = result2.uniqueLegId

        GROUP BY result1.participantCurrencyId, result2.participantCurrencyId;
    - name: allParticipantCurrencyIds
      query: >
        SELECT
          pc.participantCurrencyId,
          pc.participantId,
          pc.currencyId,
          p.name,
          p.description,
          p.isProxy
        FROM participantCurrency AS pc
        INNER JOIN
            participant AS p
            ON pc.participantId = p.participantId
        ORDER BY pc.participantCurrencyId;
    - name: allExternalParticipants
      query: >
        SELECT
          ep.externalParticipantId,
          ep.name AS externalParticipantName,
          ep.proxyId AS proxyParticipantId,
          p.name AS proxyParticipantName,
          p.participantId AS proxyParticipantId
        FROM externalParticipant ep
        LEFT JOIN participant p
          ON ep.proxyId = p.participantId
        ORDER BY ep.externalParticipantId;
    - name: quotePartiesByTransferId
      query: |
        SELECT
          qp.quotePartyId,
          qp.quoteId,
          qp.partyIdentifierValue,
          qp.participantId,
          qp.fspId,
          q.transactionReferenceId AS transferId,
          qp.amount
        FROM quoteParty qp
        INNER JOIN quote q ON qp.quoteId = q.quoteId
        LEFT JOIN amountType at ON q.amountTypeId = at.amountTypeId
        ORDER BY qp.quotePartyId;
    - name: allTransferIdsInSettlement
      query: >
        SELECT DISTINCT
          tf.transferId,
          ssw.settlementId
        FROM transferFulfilment tf
        INNER JOIN settlementSettlementWindow ssw
          ON tf.settlementWindowId = ssw.settlementWindowId
        WHERE ssw.settlementId = :settlementId
        UNION
        SELECT DISTINCT
          fxt1.determiningTransferId AS transferId,
          ssw.settlementId
        FROM fxTransferFulfilment fxtf
        INNER JOIN fxTransfer fxt1
          ON fxt1.commitRequestId = fxtf.commitRequestId
        INNER JOIN settlementSettlementWindow ssw
          ON fxtf.settlementWindowId = ssw.settlementWindowId
        WHERE ssw.settlementId = :settlementId;
    - name: conversionFspsByDeterminingTransferId
      query: >
        SELECT
          fqt.determiningTransferId AS transferId,
          fqt.initiatingFsp AS initiatingFspId,
          fqt.counterPartyFsp AS counterPartyFspId
        FROM fxQuoteConversionTerms fqt
        INNER JOIN amountType at ON fqt.amountTypeId = at.amountTypeId
        WHERE fqt.determiningTransferId IS NOT NULL;
  template: |
    <!DOCTYPE html>
    <html lang="en">

    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Bilateral Settlement Repor</title>
        <style>
            body { font-family: 'Arial', sans-serif; background-color: #f5f5f5; margin: 0; padding: 20px; color: #333; }
            .container { max-width: 100%; margin: 0 auto; background-color: #fff; padding: 20px; box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1); }
            .header { display: flex; justify-content: space-between; align-items: center; border-bottom: 2px solid #00447c; padding-bottom: 10px; }
            .header h1 { margin: 0; color: #00447c; font-size: 24px; }
            .header img { max-height: 50px; }
            .summary { margin-top: 20px; padding: 15px; background-color: #e9f3fa; border-left: 6px solid #00447c; border-radius: 5px; box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1); max-width: 500px; }
            .summary p { margin: 5px 0; font-weight: bold; }
            table { width: 100%; border-collapse: collapse; margin-top: 20px; }
            table, th, td { border: 1px solid #ddd; }
            th { background-color: #00447c; color: #fff; padding: 10px; font-size: 1.0em; }
            td { line-height: 1.6; padding: 10px; text-align: left; font-size: 0.9em; }
            tr:nth-child(even) { background-color: #f2f2f2; }
            .sub-table { margin: 10px 0 20px 30px; width: 95%; }
            .sub-table th { background-color: #007bff; }
            .footer { margin-top: 20px; text-align: center; font-size: 0.9em; color: #666; }
            .footer p { margin: 5px 0; }
        </style>
    </head>
    <body>
    <%
      // Build a map: transferId -> array of quoteParty objects
      const quotePartiesByTransferIdMap = {};
      for (const qp of quotePartiesByTransferId) {
        if (!quotePartiesByTransferIdMap[qp.transferId]) {
          quotePartiesByTransferIdMap[qp.transferId] = [];
        }
        quotePartiesByTransferIdMap[qp.transferId].push(qp);
      }

      // Build a map: determiningTransferId -> conversion FSPs object
      const conversionFspsByTransferIdMap = {};
      for (const conv of conversionFspsByDeterminingTransferId) {
        if (conv.transferId) {
          conversionFspsByTransferIdMap[conv.transferId] = conv;
        }
      }
    %>
    <%
      // Group settlementParticipantCurrencyIdsResult by quoteParty FSP ID using transferId
      const fspIdGroups = {};
      for (const txn of settlementParticipantCurrencyIdsResult) {
        const quoteParties = quotePartiesByTransferIdMap[txn.transferId] || [];
        for (const qp of quoteParties) {
          const fspId = qp.fspId || 'Unknown FSP';
          if (!fspIdGroups[fspId]) fspIdGroups[fspId] = [];
          fspIdGroups[fspId].push({
            ...txn,
            quoteParty: qp
          });
        }
      }
    %>
    <%
      function calculateNetSettlement(input) {
      const transactionsMap = new Map();
      function generateKey(debtorId, creditorId) { return `${debtorId}_${creditorId}`; }
      input.forEach(transaction => {
        const { debtorParticipantCurrencyId, creditorParticipantCurrencyId, debtorTotalAmount } = transaction;
        const key = generateKey(debtorParticipantCurrencyId, creditorParticipantCurrencyId);
        if (!transactionsMap.has(key)) {
        transactionsMap.set(key, {
          netDebtor: debtorParticipantCurrencyId,
          netCreditor: creditorParticipantCurrencyId,
          totalAmountSent: parseFloat(debtorTotalAmount),
          totalReverseAmount: 0
        });
        } else {
        transactionsMap.get(key).totalAmountSent += parseFloat(debtorTotalAmount);
        }
        const reverseKey = generateKey(creditorParticipantCurrencyId, debtorParticipantCurrencyId);
        if (transactionsMap.has(reverseKey)) {
        if (transactionsMap.get(reverseKey).totalAmountSent >= parseFloat(debtorTotalAmount)) {
          transactionsMap.get(reverseKey).totalReverseAmount -= parseFloat(debtorTotalAmount);
          transactionsMap.delete(key);
        } else {
          transactionsMap.get(key).totalReverseAmount = -transactionsMap.get(reverseKey).totalAmountSent;
          transactionsMap.delete(reverseKey);
        }
        }
      });
      const output = [];
      transactionsMap.forEach(transaction => {
        const { netDebtor, netCreditor, totalAmountSent, totalReverseAmount } = transaction;
        const netSettlementAmount = totalAmountSent + totalReverseAmount;
        output.push({
        netDebtor,
        netCreditor,
        totalAmountSent,
        totalReverseAmount,
        netSettlementAmount
        });
      });
      return output;
      }

      // Helper: get participant details
      function getParticipantCurrencyDetails(participantCurrencyId) {
      return allParticipantCurrencyIds.find((pc) => pc.participantCurrencyId === participantCurrencyId);
      }
      // Use quotePartiesByTransferId to find the correct external participant for a participantCurrencyId
      function getExternalParticipant(participantCurrencyId) {
        const pc = getParticipantCurrencyDetails(participantCurrencyId);
        if (!pc) return null;
        // Use quotePartiesByTransferIdMap to find quoteParty with matching participantId
        for (const transferId in quotePartiesByTransferIdMap) {
          const quoteParties = quotePartiesByTransferIdMap[transferId];
          const quoteParty = quoteParties.find(qp => qp.participantId === pc.participantId);
          if (quoteParty && quoteParty.partyIdentifierValue) {
        // Find external participant whose externalParticipantId matches the partyIdentifierValue
        const ext = allExternalParticipants.find(ep => ep.externalParticipantId === quoteParty.partyIdentifierValue);
        if (ext) return ext;
          }
        }
        // Fallback: Try proxy match as before
        //if (pc && pc.participantId) {
        //  return allExternalParticipants.find(eo => eo.proxyParticipantId === pc.participantId) || null;
        //}
        return null;
      }


      // Calculate main net settlements
      const calculatedSettlementRows = calculateNetSettlement(settlementParticipantCurrencyIdsResult);

      // For each main row, calculate sub-table rows (breakdown by end participants)
      function isProxy(pc) { return !!pc && !!pc.isProxy; }
      function isExternal(pc) {
        // A participant is considered external if it is a proxy for an external participant
        return !!getExternalParticipant(pc.participantCurrencyId);
      }

      // For each main row, find all underlying transactions that match the proxy
      function calculateSubTableRows(mainRow) {
      const proxyDebtor = getParticipantCurrencyDetails(mainRow.netDebtor);
      const proxyCreditor = getParticipantCurrencyDetails(mainRow.netCreditor);

      if (!isProxy(proxyDebtor) && !isProxy(proxyCreditor)) return [];

      const relevantTxns = settlementParticipantCurrencyIdsResult.filter(txn => {
        if (isProxy(proxyDebtor) && txn.debtorParticipantCurrencyId === proxyDebtor.participantCurrencyId) return true;
        if (isProxy(proxyCreditor) && txn.creditorParticipantCurrencyId === proxyCreditor.participantCurrencyId) return true;
        return false;
      });

      const subRows = [];
      relevantTxns.forEach(txn => {
        let endDebtor = getParticipantCurrencyDetails(txn.debtorParticipantCurrencyId);
        let endCreditor = getParticipantCurrencyDetails(txn.creditorParticipantCurrencyId);

        if (
        (proxyDebtor && txn.debtorParticipantCurrencyId === proxyDebtor.participantCurrencyId &&
          (!isProxy(endCreditor) || endCreditor.participantCurrencyId !== proxyCreditor.participantCurrencyId))
        ||
        (proxyCreditor && txn.creditorParticipantCurrencyId === proxyCreditor.participantCurrencyId &&
          (!isProxy(endDebtor) || endDebtor.participantCurrencyId !== proxyDebtor.participantCurrencyId))
        ) {
        const netRows = calculateNetSettlement([txn]);
        if (netRows.length > 0) {
          subRows.push({
          ...netRows[0],
          payerParticipantCurrencyDetails: endDebtor,
          payeeParticipantCurrencyDetails: endCreditor,
          payerExternalParticipant: getExternalParticipant(endDebtor.participantCurrencyId),
          payeeExternalParticipant: getExternalParticipant(endCreditor.participantCurrencyId)
          });
        }
        }
      });
      return subRows;
      }

      // Build main table rows with details and sub-table
      const calculatedSettlementRowsWithDetails = calculatedSettlementRows.map((mainRow) => {
      const payerParticipantCurrencyDetails = getParticipantCurrencyDetails(mainRow.netDebtor);
      const payeeParticipantCurrencyDetails = getParticipantCurrencyDetails(mainRow.netCreditor);
      const payerExternalParticipant = getExternalParticipant(mainRow.netDebtor);
      const payeeExternalParticipant = getExternalParticipant(mainRow.netCreditor);
      const subTableRows = calculateSubTableRows(mainRow);
      return {
        ...mainRow,
        payerParticipantCurrencyDetails,
        payeeParticipantCurrencyDetails,
        payerExternalParticipant,
        payeeExternalParticipant,
        subTableRows
      };
      });

      const settlementInfo = settlementInfoResult[0];
      const dataForJson = {
      settlementInfo,
      calculatedSettlementRowsWithDetails
      }
    %>
    <%
      // Group settlementParticipantCurrencyIdsResult by quoteParty fspId outside the HTML for EJS compatibility
      const fspGroups = {};
      for (const txn of settlementParticipantCurrencyIdsResult) {
        const quoteParties = quotePartiesByTransferIdMap[txn.transferId] || [];
        for (const qp of quoteParties) {
          const fspId = qp.fspId || 'Unknown FSP';
          if (!fspGroups[fspId]) fspGroups[fspId] = [];
          fspGroups[fspId].push({
            ...txn,
            quoteParty: qp
          });
        }
      }
      const fspGroupKeys = Object.keys(fspGroups);
    %>

    <body data-json="<%= JSON.stringify(dataForJson) %>">
      <div class="container">
      <div class="header">
      <h1>DRPP Bilateral Net Settlement Report (External Participants)</h1>
      <img src="" alt="Logo">
      </div>

      <div class="summary">
      <p>Settlement ID: <%= settlementInfo?.settlementId %></p>
      <p>State: <%= settlementInfo?.currentState %></p>
      <p>Earliest Window Start: <%= settlementInfo?.windowOpenDate.toISOString() %></p>
      <p>Latest Window Finish: <%= settlementInfo?.windowClosedDate.toISOString() %></p>
      <p>Created Date: <%= settlementInfo?.createdDate.toISOString() %></p>
      <p>Last State Update: <%= settlementInfo?.lastStateUpdate.toISOString() %></p>
      </div>

      <div class="container" style="margin-top:30px;">
      <h2>Net Settlement Table</h2>
      <table>
      <thead>
      <tr>
      <th>Net Debtor</th>
      <th>Net Creditor</th>
      <th>Currency</th>
      <th>Total Sent Amount</th>
      <th>Total Received Amount</th>
      <th>Net Settlement Amount</th>
      <th>Currency</th>
      </tr>
      </thead>
      <tbody>
      <%
      // Helper to format numbers with commas and 2 decimals
      function fmt(n, opts) {
      if (n === undefined || n === null || isNaN(n)) return '';
      const num = Number(n);
      const abs = Math.abs(num).toLocaleString(undefined, {minimumFractionDigits:2, maximumFractionDigits:2});
      if (opts && opts.forceParens) return `(${abs})`;
      if (opts && opts.parensIfNegative && num < 0) return `(${abs})`;
      return num < 0 ? `(${abs})` : abs;
      }
      // Helper to get name or fallback
      function pcName(pc) { return pc ? pc.name : ''; }
      // Helper to get currency
      function pcCurrency(pc) { return pc ? pc.currencyId : ''; }
      // Helper to get external participant name
      function extName(ext, fallback) { return ext ? ext.externalParticipantName : (fallback || ''); }
      function isProxy(pc) { return !!pc && !!pc.isProxy; }

      // --- NEW: Show every FSP-to-FSP movement for main rows (do not net out reverse) ---
      // But: If net creditor has position movements to net debtor, put that movement in total received amount of the main row (not as a new row).
      // Also: Prioritize showing non-proxy FSPs as net debtor first.

      // Build a map for quick lookup of participantCurrencyId -> participantCurrency object
      const pcMap = {};
      for (const pc of allParticipantCurrencyIds) {
      pcMap[pc.participantCurrencyId] = pc;
      }

      // Build a map of all movements: [debtor, creditor] -> {sent, received}
      const movementPairs = {};
      for (const txn of settlementParticipantCurrencyIdsResult) {
      const key = txn.debtorParticipantCurrencyId + '_' + txn.creditorParticipantCurrencyId;
      if (!movementPairs[key]) {
      movementPairs[key] = {
      debtor: txn.debtorParticipantCurrencyId,
      creditor: txn.creditorParticipantCurrencyId,
      sent: 0,
      received: 0
      };
      }
      movementPairs[key].sent += Number(txn.debtorTotalAmount);
      movementPairs[key].received += Number(txn.creditorTotalAmount);
      }

      // Now, for each unique [debtor, creditor], if there is a reverse [creditor, debtor], add its sent to received and do not show the reverse as a main row
      const shownKeys = new Set();
      const mainRows = [];

      // Helper: sort so non-proxy debtors come first
      function sortMainRows(a, b) {
      const aDebtorIsProxy = isProxy(pcMap[a.debtor]);
      const bDebtorIsProxy = isProxy(pcMap[b.debtor]);
      if (aDebtorIsProxy === bDebtorIsProxy) return 0;
      return aDebtorIsProxy ? 1 : -1;
      }

      for (const key in movementPairs) {
      if (shownKeys.has(key)) continue;
      const { debtor, creditor, sent } = movementPairs[key];
      const reverseKey = creditor + '_' + debtor;
      let totalSent = sent;
      let totalReceived = 0;

      // If reverse exists, add its sent to received and mark reverse as shown
      if (movementPairs[reverseKey]) {
      totalReceived += movementPairs[reverseKey].sent;
      shownKeys.add(reverseKey);
      }
      shownKeys.add(key);

      // Net settlement is total sent - abs(total received)
      let netSettlement = totalSent - Math.abs(totalReceived);

      mainRows.push({
      debtor,
      creditor,
      totalSent,
      totalReceived,
      netSettlement
      });
      }

      // Sort so non-proxy debtors come first
      mainRows.sort(sortMainRows);

      // For sub-rows: group by underlying creditor/debtor FSPs using quoteParty and its amount
      // When the sub row debtor->creditor has position movements in the opposite direction,
      // put that movement in the received amount sub row rather than showing the opposite direction sub row.
      // Total received amount should only reflect reverse direction movements, not affected by sent amount.
      // If no reverse movement, total received is 0.
      function sumUnderlyingFspMovements(mainRow) {
      // Find all transfers for this main row (debtor->creditor)
      const transfers = settlementParticipantCurrencyIdsResult.filter(txn =>
        txn.debtorParticipantCurrencyId === mainRow.debtor &&
        txn.creditorParticipantCurrencyId === mainRow.creditor
      );
      // Find all transfers for reverse (creditor->debtor)
      const reverseTransfers = settlementParticipantCurrencyIdsResult.filter(txn =>
        txn.debtorParticipantCurrencyId === mainRow.creditor &&
        txn.creditorParticipantCurrencyId === mainRow.debtor
      );
      // For each transfer, get quoteParties and amounts
      const movementMap = {};
      // Normal direction: build sub-rows for each unique FSP pair
      for (const txn of transfers) {
        const qps = quotePartiesByTransferIdMap[txn.transferId] || [];
        let qpDebtor = null, qpCreditor = null;
        for (const qp of qps) {
      if (Number(qp.amount) > 0) qpDebtor = qp;
      if (Number(qp.amount) < 0) qpCreditor = qp;
        }
        let debtorFspId = qpDebtor ? qpDebtor.fspId : undefined;
        let creditorFspId = qpCreditor ? qpCreditor.fspId : undefined;

        // If this transferId is in conversionFspsByTransferIdMap, check if main fspid is a counterparty or initiatingfsp
        const conv = conversionFspsByTransferIdMap[txn.transferId];
        if (conv) {
      const mainDebtorPc = pcMap[mainRow.debtor];
      const mainCreditorPc = pcMap[mainRow.creditor];
      const mainDebtorFspId = mainDebtorPc ? mainDebtorPc.name : undefined;
      const mainCreditorFspId = mainCreditorPc ? mainCreditorPc.name : undefined;
      if (mainDebtorFspId === conv.counterPartyFspId || mainDebtorFspId === conv.initiatingFspId) {
        debtorFspId = mainDebtorFspId;
      }
      if (mainCreditorFspId === conv.counterPartyFspId || mainCreditorFspId === conv.initiatingFspId) {
        creditorFspId = mainCreditorFspId;
      }
        }

        const key = (debtorFspId || '') + '_' + (creditorFspId || '');
        if (!movementMap[key]) {
      movementMap[key] = {
        debtorFspId: debtorFspId,
        creditorFspId: creditorFspId,
        currency: pcCurrency(pcMap[mainRow.debtor]) || pcCurrency(pcMap[mainRow.creditor]) || '',
        totalSent: 0,
        totalReceived: 0, // will be filled in reverse loop if any
        netSettlement: 0
      };
        }
        movementMap[key].totalSent += Number(txn.debtorTotalAmount);
      }
      // Reverse direction: add to totalReceived of the matching sub-row, not as a new sub-row
      for (const txn of reverseTransfers) {
        const qps = quotePartiesByTransferIdMap[txn.transferId] || [];
        let qpDebtor = null, qpCreditor = null;
        for (const qp of qps) {
      if (Number(qp.amount) > 0) qpDebtor = qp;
      if (Number(qp.amount) < 0) qpCreditor = qp;
        }
        let debtorFspId = qpDebtor ? qpDebtor.fspId : undefined;
        let creditorFspId = qpCreditor ? qpCreditor.fspId : undefined;

        // If this transferId is in conversionFspsByTransferIdMap, check if main fspid is a counterparty or initiatingfsp
        const conv = conversionFspsByTransferIdMap[txn.transferId];
        if (conv) {
      const mainDebtorPc = pcMap[mainRow.debtor];
      const mainCreditorPc = pcMap[mainRow.creditor];
      const mainDebtorFspId = mainDebtorPc ? mainDebtorPc.name : undefined;
      const mainCreditorFspId = mainCreditorPc ? mainCreditorPc.name : undefined;
      if (mainDebtorFspId === conv.counterPartyFspId || mainDebtorFspId === conv.initiatingFspId) {
        debtorFspId = mainDebtorFspId;
      }
      if (mainCreditorFspId === conv.counterPartyFspId || mainCreditorFspId === conv.initiatingFspId) {
        creditorFspId = mainCreditorFspId;
      }
        }

        // Try to find a matching sub-row in the normal direction (debtorFspId/creditorFspId swapped)
        const matchKey = (creditorFspId || '') + '_' + (debtorFspId || '');
        if (movementMap[matchKey]) {
      movementMap[matchKey].totalReceived += Number(txn.debtorTotalAmount);
        }
        // If not found, do not create a new sub-row; received remains 0 for unmatched
      }
      // Now calculate netSettlement for each sub-row as totalSent - abs(totalReceived)
      for (const k in movementMap) {
        movementMap[k].netSettlement = movementMap[k].totalSent - Math.abs(movementMap[k].totalReceived);
      }
      // Convert to array and enrich with names
      return Object.values(movementMap).map(sub => {
        const debtorPc = allParticipantCurrencyIds.find(pc => pc.name === sub.debtorFspId);
        const creditorPc = allParticipantCurrencyIds.find(pc => pc.name === sub.creditorFspId);
        const debtorExt = allExternalParticipants.find(ep => ep.externalParticipantName === sub.debtorFspId);
        const creditorExt = allExternalParticipants.find(ep => ep.externalParticipantName === sub.creditorFspId);
        return {
      ...sub,
      debtorName: extName(debtorExt, pcName(debtorPc)) || sub.debtorFspId,
      creditorName: extName(creditorExt, pcName(creditorPc)) || sub.creditorFspId,
      currency: sub.currency
        };
      });
      }

      // Sort so non-proxy debtors come first (prioritize non-proxy FSPs as main row debtor)
      function isProxyDebtor(row) {
      const pc = pcMap[row.debtor];
      return pc && pc.isProxy;
      }
      mainRows.sort((a, b) => {
      const aProxy = isProxyDebtor(a);
      const bProxy = isProxyDebtor(b);
      if (aProxy === bProxy) return 0;
      return aProxy ? 1 : -1;
      });

      for (const row of mainRows) {
      const payerParticipantCurrencyDetails = pcMap[row.debtor];
      const payeeParticipantCurrencyDetails = pcMap[row.creditor];
      const payerExternalParticipant = getExternalParticipant(row.debtor);
      const payeeExternalParticipant = getExternalParticipant(row.creditor);

      const netDebtorName = extName(payerExternalParticipant, pcName(payerParticipantCurrencyDetails)) || pcName(payerParticipantCurrencyDetails);
      const netCreditorName = extName(payeeExternalParticipant, pcName(payeeParticipantCurrencyDetails)) || pcName(payeeParticipantCurrencyDetails);
      const currency = pcCurrency(payeeParticipantCurrencyDetails) || pcCurrency(payerParticipantCurrencyDetails) || '';
      // Total Received Amount: always shown in ()
      const totalSent = fmt(row.totalSent);
      const totalReceived = fmt(row.totalReceived, { forceParens: row.totalReceived !== 0 });
      // Net Settlement Amount: show in () if negative
      const netSettlement = fmt(row.netSettlement, { forceParens: row.netSettlement < 0 });
      %>
      <tr style="font-weight:bold; background:#e9f3fa;">
      <td><%= netDebtorName %></td>
      <td><%= netCreditorName %></td>
      <td><%= currency %></td>
      <td><%= totalSent %></td>
      <td><%= totalReceived %></td>
      <td><%= netSettlement %></td>
      <td><%= currency %></td>
      </tr>
      <%
      // Sub-rows: show underlying creditor/debtor FSPs using quoteParty and its amount, but use settlementParticipantCurrencyIdsResult for totals
      const subRows = sumUnderlyingFspMovements(row);
      for (const sub of subRows) {
        // Sub-row: received always in (), net settlement in () if negative
        const subTotalSent = fmt(sub.totalSent);
        const subTotalReceived = fmt(sub.totalReceived, { forceParens: sub.totalReceived !== 0 });
        const subNetSettlement = fmt(sub.netSettlement, { forceParens: sub.netSettlement < 0 });
      %>
      <tr style="background:#f9f9f9;">
      <td style="padding-left:2em;">&#8627; <%= sub.debtorName %></td>
      <td><%= sub.creditorName %></td>
      <td><%= sub.currency %></td>
      <td><%= subTotalSent %></td>
      <td><%= subTotalReceived %></td>
      <td><%= subNetSettlement %></td>
      <td><%= sub.currency %></td>
      </tr>
      <%
      }
      %>
      <tr><td colspan="7" style="background:#fff; height:8px; border:none;"></td></tr>
      <%
      }
      %>
      </tbody>
      </table>
      </div>
      </div>
    </body>

    <div></div>
      <div style="margin-top:30px;">
        <button id="toggleTransfersBtn" onclick="toggleTransfersTable()" style="padding:8px 16px; background:#00447c; color:#fff; border:none; border-radius:4px; cursor:pointer;">
          Show Transfers in Settlement
        </button>
      </div>
      <div id="transfersTableContainer" style="display:none; margin-top:20px;">
        <h2 id="transfersHeader" style="margin-top:0;">Transfers in Settlement</h2>
        <table>
          <thead>
            <tr>
              <th>Transfer ID</th>
              <th>Debtor FSP</th>
              <th>Creditor FSP</th>
              <th>Debtor Currency</th>
              <th>Creditor Currency</th>
              <th>Debtor Amount</th>
              <th>Creditor Amount</th>
              <th>Quote ID</th>
              <th>Quote Party Debtor</th>
              <th>Quote Party Creditor</th>
            </tr>
          </thead>
          <tbody>
            <%
              // Helper to get quote party by transferId and amount sign
              function getQuotePartyByAmount(qps, sign) {
                return qps.find(qp => (sign > 0 ? Number(qp.amount) > 0 : Number(qp.amount) < 0));
              }
              for (const txn of settlementParticipantCurrencyIdsResult) {
                const transferId = txn.transferId;
                const debtorPC = allParticipantCurrencyIds.find(pc => pc.participantCurrencyId === txn.debtorParticipantCurrencyId);
                const creditorPC = allParticipantCurrencyIds.find(pc => pc.participantCurrencyId === txn.creditorParticipantCurrencyId);
                const qps = quotePartiesByTransferIdMap[transferId] || [];
                const qpDebtor = getQuotePartyByAmount(qps, 1);
                const qpCreditor = getQuotePartyByAmount(qps, -1);
            %>
            <tr>
              <td><%= transferId %></td>
              <td><%= debtorPC ? debtorPC.name : '' %></td>
              <td><%= creditorPC ? creditorPC.name : '' %></td>
              <td><%= debtorPC ? debtorPC.currencyId : '' %></td>
              <td><%= creditorPC ? creditorPC.currencyId : '' %></td>
              <td><%= fmt(txn.debtorTotalAmount) %></td>
              <td><%= fmt(txn.creditorTotalAmount) %></td>
              <td><%= qpDebtor ? qpDebtor.quoteId : (qpCreditor ? qpCreditor.quoteId : '') %></td>
              <td><%= qpDebtor ? qpDebtor.partyIdentifierValue : '' %></td>
              <td><%= qpCreditor ? qpCreditor.partyIdentifierValue : '' %></td>
            </tr>
            <%
              }
            %>
          </tbody>
        </table>
      </div>
    </div>
    <script>
        function toggleTransfersTable() {
          var container = document.getElementById('transfersTableContainer');
          var btn = document.getElementById('toggleTransfersBtn');
          var header = document.getElementById('transfersHeader');
          if (container.style.display === 'none') {
        container.style.display = '';
        btn.textContent = 'Hide Transfers in Settlement';
        if (header) header.style.marginTop = '30px';
          } else {
        container.style.display = 'none';
        btn.textContent = 'Show Transfers in Settlement';
        if (header) header.style.marginTop = '0';
          }
        }
    </script>
    </html>
