apiVersion: mojaloop.io/v1
kind: MojaloopReport
metadata:
  name: reporting-bilateral-settlements-external-participants
spec:
  endpoint:
    params:
      - name: settlementId
        required: true
    path: /reporting-bilateral-settlements-external-participants
  permission: transferApi
  queries:
    - name: settlementInfoResult
      query: >
        SELECT
            s.settlementId,
            s.createdDate,
            ssc.settlementStateId as currentState,
            ssc.createdDate as lastStateUpdate,
            sSW.createdDate as windowCreatedDate,
            sSW.settlementWindowId,
            MIN(sWSCOpen.createdDate) as windowOpenDate,
            MAX(sWSCClosed.createdDate) as windowClosedDate
        FROM settlement s
        INNER JOIN settlementSettlementWindow sSW
                on s.settlementId = sSW.settlementId
        INNER JOIN settlementWindowStateChange sWSCOpen
                on sSW.settlementWindowId = sWSCOpen.settlementWindowId AND sWSCOpen.settlementWindowStateId = 'OPEN'
        INNER JOIN settlementWindowStateChange sWSCClosed
                on sSW.settlementWindowId = sWSCClosed.settlementWindowId AND sWSCClosed.settlementWindowStateId = 'CLOSED'
        INNER JOIN settlementStateChange ssc
            on s.currentStateChangeId = ssc.settlementStateChangeId
        WHERE s.settlementId = :settlementId
        GROUP BY s.settlementId, sSW.settlementWindowId;
    - name: settlementParticipantCurrencyIdsResult
      query: >
        SELECT
          result1.transferId,
          result1.uniqueLegId,
          result1.participantCurrencyId as debtorParticipantCurrencyId,
          result2.participantCurrencyId as creditorParticipantCurrencyId,
          SUM(result1.amount) as debtorTotalAmount,
          SUM(result2.amount) as creditorTotalAmount
        FROM

        (SELECT
          pc.participantCurrencyId,
          unioned.transferId,
          unioned.uniqueLegId,
          SUM(unioned.change) as amount
        FROM (
          SELECT
            ppc.participantCurrencyId,
            ppc.change,
            tf.settlementWindowId,
            tf.transferId AS transferId,
            tf.transferId AS uniqueLegId
          FROM
            transferFulfilment AS tf
          INNER JOIN
            transferStateChange AS tsc
            ON tsc.transferId = tf.transferId
          INNER JOIN
            participantPositionChange AS ppc
            ON ppc.transferStateChangeId = tsc.transferStateChangeId
          INNER JOIN
            settlementParticipantCurrency AS spc
            ON ppc.participantCurrencyId = spc.participantCurrencyId AND spc.settlementId = :settlementId
          INNER JOIN
            settlementSettlementWindow ssw
            ON tf.settlementWindowId = ssw.settlementWindowId AND ssw.settlementId = :settlementId

          UNION ALL

          SELECT
            ppc.participantCurrencyId,
            ppc.change,
            fxtf.settlementWindowId,
            fxt1.determiningTransferId AS transferId,
            fxt1.commitRequestId AS uniqueLegId
          FROM
            fxTransferFulfilment AS fxtf
          INNER JOIN
            fxTransfer AS fxt1
            ON fxt1.commitRequestId = fxtf.commitRequestId
          INNER JOIN
            fxTransferStateChange AS fxtsc
            ON fxtsc.commitRequestId = fxtf.commitRequestId
          INNER JOIN
            participantPositionChange AS ppc
            ON ppc.fxTransferStateChangeId = fxtsc.fxTransferStateChangeId
          INNER JOIN
            settlementParticipantCurrency AS spc
            ON ppc.participantCurrencyId = spc.participantCurrencyId AND spc.settlementId = :settlementId
          INNER JOIN
            settlementSettlementWindow ssw
            ON fxtf.settlementWindowId = ssw.settlementWindowId AND ssw.settlementId = :settlementId
        ) AS unioned
        INNER JOIN
          participantCurrency AS pc
          ON pc.participantCurrencyId = unioned.participantCurrencyId
        WHERE unioned.change > 0
        GROUP BY
          unioned.transferId,
          unioned.uniqueLegId,
          pc.participantCurrencyId
        ORDER BY unioned.transferId
        ) as result1

        INNER JOIN

        (SELECT
          pc.participantCurrencyId,
          unioned.transferId,
          unioned.uniqueLegId,
          SUM(unioned.change) as amount
        FROM (
          SELECT
            ppc.participantCurrencyId,
            ppc.change,
            tf.settlementWindowId,
            tf.transferId AS transferId,
            tf.transferId AS uniqueLegId
          FROM
            transferFulfilment AS tf
          INNER JOIN
            transferStateChange AS tsc
            ON tsc.transferId = tf.transferId
          INNER JOIN
            participantPositionChange AS ppc
            ON ppc.transferStateChangeId = tsc.transferStateChangeId
          INNER JOIN
            settlementParticipantCurrency AS spc
            ON ppc.participantCurrencyId = spc.participantCurrencyId AND spc.settlementId = :settlementId
          INNER JOIN
            settlementSettlementWindow ssw
            ON tf.settlementWindowId = ssw.settlementWindowId AND ssw.settlementId = :settlementId

          UNION ALL

          SELECT
            ppc.participantCurrencyId,
            ppc.change,
            fxtf.settlementWindowId,
            fxt1.determiningTransferId AS transferId,
            fxt1.commitRequestId AS uniqueLegId
          FROM
            fxTransferFulfilment AS fxtf
          INNER JOIN
            fxTransfer AS fxt1
            ON fxt1.commitRequestId = fxtf.commitRequestId
          INNER JOIN
            fxTransferStateChange AS fxtsc
            ON fxtsc.commitRequestId = fxtf.commitRequestId
          INNER JOIN
            participantPositionChange AS ppc
            ON ppc.fxTransferStateChangeId = fxtsc.fxTransferStateChangeId
          INNER JOIN
            settlementParticipantCurrency AS spc
            ON ppc.participantCurrencyId = spc.participantCurrencyId AND spc.settlementId = :settlementId
          INNER JOIN
            settlementSettlementWindow ssw
            ON fxtf.settlementWindowId = ssw.settlementWindowId AND ssw.settlementId = :settlementId
        ) AS unioned
        INNER JOIN
          participantCurrency AS pc
          ON pc.participantCurrencyId = unioned.participantCurrencyId
        WHERE unioned.change < 0
        GROUP BY
          unioned.transferId,
          unioned.uniqueLegId,
          pc.participantCurrencyId
        ORDER BY unioned.transferId
        ) as result2

        ON result1.transferId = result2.transferId AND result1.uniqueLegId = result2.uniqueLegId

        GROUP BY result1.transferId, result1.uniqueLegId, result1.participantCurrencyId, result2.participantCurrencyId;
    - name: allParticipantCurrencyIds
      query: >
        SELECT
          pc.participantCurrencyId,
          pc.participantId,
          pc.currencyId,
          p.name,
          p.description,
          p.isProxy
        FROM participantCurrency AS pc
        INNER JOIN
            participant AS p
            ON pc.participantId = p.participantId
        ORDER BY pc.participantCurrencyId;
    - name: allExternalParticipants
      query: >
        SELECT
          ep.externalParticipantId,
          ep.name AS externalParticipantName,
          ep.proxyId AS proxyParticipantId,
          p.name AS proxyParticipantName,
          p.participantId AS proxyParticipantId
        FROM externalParticipant ep
        LEFT JOIN participant p
          ON ep.proxyId = p.participantId
        ORDER BY ep.externalParticipantId;
    - name: quotePartiesByTransferId
      query: |
        SELECT
          qp.quotePartyId,
          qp.quoteId,
          qp.partyIdentifierValue,
          qp.participantId,
          qp.fspId,
          q.transactionReferenceId AS transferId,
          qp.amount,
          at.name AS amountType
        FROM quoteParty qp
        INNER JOIN quote q ON qp.quoteId = q.quoteId
        LEFT JOIN amountType at ON q.amountTypeId = at.amountTypeId
        ORDER BY qp.quotePartyId;
    - name: allTransferIdsInSettlement
      query: >
        SELECT DISTINCT
          tf.transferId,
          ssw.settlementId
        FROM transferFulfilment tf
        INNER JOIN settlementSettlementWindow ssw
          ON tf.settlementWindowId = ssw.settlementWindowId
        WHERE ssw.settlementId = :settlementId
        UNION
        SELECT DISTINCT
          fxt1.determiningTransferId AS transferId,
          ssw.settlementId
        FROM fxTransferFulfilment fxtf
        INNER JOIN fxTransfer fxt1
          ON fxt1.commitRequestId = fxtf.commitRequestId
        INNER JOIN settlementSettlementWindow ssw
          ON fxtf.settlementWindowId = ssw.settlementWindowId
        WHERE ssw.settlementId = :settlementId;
    - name: conversionFspsByDeterminingTransferId
      query: >
      SELECT
        fqt.determiningTransferId AS transferId,
        fqt.initiatingFsp AS initiatingFspId,
        fqt.counterPartyFsp AS counterPartyFspId,
        at.name AS amountType
      FROM fxQuoteConversionTerms fqt
      INNER JOIN amountType at ON fqt.amountTypeId = at.amountTypeId
      WHERE fqt.determiningTransferId IS NOT NULL;
  template: |
    <!DOCTYPE html>
    <html lang="en">

    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Bilateral Settlement Repor</title>
        <style>
            body { font-family: 'Arial', sans-serif; background-color: #f5f5f5; margin: 0; padding: 20px; color: #333; }
            .container { max-width: 100%; margin: 0 auto; background-color: #fff; padding: 20px; box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1); }
            .header { display: flex; justify-content: space-between; align-items: center; border-bottom: 2px solid #00447c; padding-bottom: 10px; }
            .header h1 { margin: 0; color: #00447c; font-size: 24px; }
            .header img { max-height: 50px; }
            .summary { margin-top: 20px; padding: 15px; background-color: #e9f3fa; border-left: 6px solid #00447c; border-radius: 5px; box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1); max-width: 500px; }
            .summary p { margin: 5px 0; font-weight: bold; }
            table { width: 100%; border-collapse: collapse; margin-top: 20px; }
            table, th, td { border: 1px solid #ddd; }
            th { background-color: #00447c; color: #fff; padding: 10px; font-size: 1.0em; }
            td { line-height: 1.6; padding: 10px; text-align: left; font-size: 0.9em; }
            tr:nth-child(even) { background-color: #f2f2f2; }
            .sub-table { margin: 10px 0 20px 30px; width: 95%; }
            .sub-table th { background-color: #007bff; }
            .footer { margin-top: 20px; text-align: center; font-size: 0.9em; color: #666; }
            .footer p { margin: 5px 0; }
        </style>
    </head>
    <body>
    <%
      // Build a map: transferId -> array of quoteParty objects
      const quotePartiesByTransferIdMap = {};
      for (const qp of quotePartiesByTransferId) {
        if (!quotePartiesByTransferIdMap[qp.transferId]) {
          quotePartiesByTransferIdMap[qp.transferId] = [];
        }
        quotePartiesByTransferIdMap[qp.transferId].push(qp);
      }

      // Build a map: determiningTransferId -> conversion FSPs object
      const conversionFspsByTransferIdMap = {};
      for (const conv of conversionFspsByDeterminingTransferId) {
        if (conv.transferId) {
          conversionFspsByTransferIdMap[conv.transferId] = conv;
        }
      }
    %>
    <%
      // Group settlementParticipantCurrencyIdsResult by quoteParty FSP ID using transferId
      const fspIdGroups = {};
      for (const txn of settlementParticipantCurrencyIdsResult) {
        const quoteParties = quotePartiesByTransferIdMap[txn.transferId] || [];
        for (const qp of quoteParties) {
          const fspId = qp.fspId || 'Unknown FSP';
          if (!fspIdGroups[fspId]) fspIdGroups[fspId] = [];
          fspIdGroups[fspId].push({
            ...txn,
            quoteParty: qp
          });
        }
      }
    %>
    <%
      function calculateNetSettlement(input) {
      const transactionsMap = new Map();
      function generateKey(debtorId, creditorId) { return `${debtorId}_${creditorId}`; }
      input.forEach(transaction => {
        const { debtorParticipantCurrencyId, creditorParticipantCurrencyId, debtorTotalAmount } = transaction;
        const key = generateKey(debtorParticipantCurrencyId, creditorParticipantCurrencyId);
        if (!transactionsMap.has(key)) {
        transactionsMap.set(key, {
          netDebtor: debtorParticipantCurrencyId,
          netCreditor: creditorParticipantCurrencyId,
          totalAmountSent: parseFloat(debtorTotalAmount),
          totalReverseAmount: 0
        });
        } else {
        transactionsMap.get(key).totalAmountSent += parseFloat(debtorTotalAmount);
        }
        const reverseKey = generateKey(creditorParticipantCurrencyId, debtorParticipantCurrencyId);
        if (transactionsMap.has(reverseKey)) {
        if (transactionsMap.get(reverseKey).totalAmountSent >= parseFloat(debtorTotalAmount)) {
          transactionsMap.get(reverseKey).totalReverseAmount -= parseFloat(debtorTotalAmount);
          transactionsMap.delete(key);
        } else {
          transactionsMap.get(key).totalReverseAmount = -transactionsMap.get(reverseKey).totalAmountSent;
          transactionsMap.delete(reverseKey);
        }
        }
      });
      const output = [];
      transactionsMap.forEach(transaction => {
        const { netDebtor, netCreditor, totalAmountSent, totalReverseAmount } = transaction;
        const netSettlementAmount = totalAmountSent + totalReverseAmount;
        output.push({
        netDebtor,
        netCreditor,
        totalAmountSent,
        totalReverseAmount,
        netSettlementAmount
        });
      });
      return output;
      }

      // Helper: get participant details
      function getParticipantCurrencyDetails(participantCurrencyId) {
      return allParticipantCurrencyIds.find((pc) => pc.participantCurrencyId === participantCurrencyId);
      }
      // Use quotePartiesByTransferId to find the correct external participant for a participantCurrencyId
      function getExternalParticipant(participantCurrencyId) {
        const pc = getParticipantCurrencyDetails(participantCurrencyId);
        if (!pc) return null;
        // Use quotePartiesByTransferIdMap to find quoteParty with matching participantId
        for (const transferId in quotePartiesByTransferIdMap) {
          const quoteParties = quotePartiesByTransferIdMap[transferId];
          const quoteParty = quoteParties.find(qp => qp.participantId === pc.participantId);
          if (quoteParty && quoteParty.partyIdentifierValue) {
        // Find external participant whose externalParticipantId matches the partyIdentifierValue
        const ext = allExternalParticipants.find(ep => ep.externalParticipantId === quoteParty.partyIdentifierValue);
        if (ext) return ext;
          }
        }
        // Fallback: Try proxy match as before
        //if (pc && pc.participantId) {
        //  return allExternalParticipants.find(eo => eo.proxyParticipantId === pc.participantId) || null;
        //}
        return null;
      }


      // Calculate main net settlements
      const calculatedSettlementRows = calculateNetSettlement(settlementParticipantCurrencyIdsResult);

      // For each main row, calculate sub-table rows (breakdown by end participants)
      function isProxy(pc) { return !!pc && !!pc.isProxy; }
      function isExternal(pc) {
        // A participant is considered external if it is a proxy for an external participant
        return !!getExternalParticipant(pc.participantCurrencyId);
      }

      // For each main row, find all underlying transactions that match the proxy
      function calculateSubTableRows(mainRow) {
      const proxyDebtor = getParticipantCurrencyDetails(mainRow.netDebtor);
      const proxyCreditor = getParticipantCurrencyDetails(mainRow.netCreditor);

      if (!isProxy(proxyDebtor) && !isProxy(proxyCreditor)) return [];

      const relevantTxns = settlementParticipantCurrencyIdsResult.filter(txn => {
        if (isProxy(proxyDebtor) && txn.debtorParticipantCurrencyId === proxyDebtor.participantCurrencyId) return true;
        if (isProxy(proxyCreditor) && txn.creditorParticipantCurrencyId === proxyCreditor.participantCurrencyId) return true;
        return false;
      });

      const subRows = [];
      relevantTxns.forEach(txn => {
        let endDebtor = getParticipantCurrencyDetails(txn.debtorParticipantCurrencyId);
        let endCreditor = getParticipantCurrencyDetails(txn.creditorParticipantCurrencyId);

        if (
        (proxyDebtor && txn.debtorParticipantCurrencyId === proxyDebtor.participantCurrencyId &&
          (!isProxy(endCreditor) || endCreditor.participantCurrencyId !== proxyCreditor.participantCurrencyId))
        ||
        (proxyCreditor && txn.creditorParticipantCurrencyId === proxyCreditor.participantCurrencyId &&
          (!isProxy(endDebtor) || endDebtor.participantCurrencyId !== proxyDebtor.participantCurrencyId))
        ) {
        const netRows = calculateNetSettlement([txn]);
        if (netRows.length > 0) {
          subRows.push({
          ...netRows[0],
          payerParticipantCurrencyDetails: endDebtor,
          payeeParticipantCurrencyDetails: endCreditor,
          payerExternalParticipant: getExternalParticipant(endDebtor.participantCurrencyId),
          payeeExternalParticipant: getExternalParticipant(endCreditor.participantCurrencyId)
          });
        }
        }
      });
      return subRows;
      }

      // Build main table rows with details and sub-table
      const calculatedSettlementRowsWithDetails = calculatedSettlementRows.map((mainRow) => {
      const payerParticipantCurrencyDetails = getParticipantCurrencyDetails(mainRow.netDebtor);
      const payeeParticipantCurrencyDetails = getParticipantCurrencyDetails(mainRow.netCreditor);
      const payerExternalParticipant = getExternalParticipant(mainRow.netDebtor);
      const payeeExternalParticipant = getExternalParticipant(mainRow.netCreditor);
      const subTableRows = calculateSubTableRows(mainRow);
      return {
        ...mainRow,
        payerParticipantCurrencyDetails,
        payeeParticipantCurrencyDetails,
        payerExternalParticipant,
        payeeExternalParticipant,
        subTableRows
      };
      });

      const settlementInfo = settlementInfoResult[0];
      const dataForJson = {
      settlementInfo,
      calculatedSettlementRowsWithDetails
      }
    %>
    <%
      // Group settlementParticipantCurrencyIdsResult by quoteParty fspId outside the HTML for EJS compatibility
      const fspGroups = {};
      for (const txn of settlementParticipantCurrencyIdsResult) {
        const quoteParties = quotePartiesByTransferIdMap[txn.transferId] || [];
        for (const qp of quoteParties) {
          const fspId = qp.fspId || 'Unknown FSP';
          if (!fspGroups[fspId]) fspGroups[fspId] = [];
          fspGroups[fspId].push({
            ...txn,
            quoteParty: qp
          });
        }
      }
      const fspGroupKeys = Object.keys(fspGroups);
    %>

    <body data-json="<%= JSON.stringify(dataForJson) %>">
      <div class="container">
      <div class="header">
      <h1>DRPP Bilateral Net Settlement Report (External Participants)</h1>
      <img src="" alt="Logo">
      </div>

      <div class="summary">
      <p>Settlement ID: <%= settlementInfo?.settlementId %></p>
      <p>State: <%= settlementInfo?.currentState %></p>
      <p>Earliest Window Start: <%= settlementInfo?.windowOpenDate.toISOString() %></p>
      <p>Latest Window Finish: <%= settlementInfo?.windowClosedDate.toISOString() %></p>
      <p>Created Date: <%= settlementInfo?.createdDate.toISOString() %></p>
      <p>Last State Update: <%= settlementInfo?.lastStateUpdate.toISOString() %></p>
      </div>

      <div class="container" style="margin-top:30px;">
      <h2>Net Settlement Table</h2>
      <table>
      <thead>
      <tr>
      <th>Net Debtor</th>
      <th>Net Creditor</th>
      <th>Currency</th>
      <th>Total Sent Amount</th>
      <th>Net Settlement Amount</th>
      <th>Currency</th>
      </tr>
      </thead>
      <tbody>
      <%
      // Helper to format numbers with commas and 2 decimals
      function fmt(n) {
      if (n === undefined || n === null || isNaN(n)) return '';
      const num = Number(n);
      return num < 0
      ? `(${Math.abs(num).toLocaleString(undefined, {minimumFractionDigits:2, maximumFractionDigits:2})})`
      : num.toLocaleString(undefined, {minimumFractionDigits:2, maximumFractionDigits:2});
      }
      // Helper to get name or fallback
      function pcName(pc) { return pc ? pc.name : ''; }
      // Helper to get currency
      function pcCurrency(pc) { return pc ? pc.currencyId : ''; }
      // Helper to get external participant name
      function extName(ext, fallback) { return ext ? ext.externalParticipantName : (fallback || ''); }

      // For sub-rows: group by underlying creditor/debtor FSPs using quoteParty and its amount
      // But for totals, use the actual settlementParticipantCurrencyIdsResult amounts
      function sumUnderlyingFspMovements(mainRow) {
      // Only consider transfers where the main row's debtor is the proxy
      const proxyDebtorId = mainRow.payerParticipantCurrencyDetails?.participantId;
      const proxyCreditorId = mainRow.payeeParticipantCurrencyDetails?.participantId;
      // Find all transfers for this main row
      const transfers = settlementParticipantCurrencyIdsResult.filter(txn =>
      txn.debtorParticipantCurrencyId === mainRow.netDebtor &&
      txn.creditorParticipantCurrencyId === mainRow.netCreditor
      );
      // For each transfer, get quoteParties and amounts
      const movementMap = {};
      for (const txn of transfers) {
      const qps = quotePartiesByTransferIdMap[txn.transferId] || [];
      // Find all unique underlying creditor/debtor pairs using quoteParty and their amounts
      // But for totals, use txn.debtorTotalAmount and txn.creditorTotalAmount
      // Find the underlying creditor and debtor FSPs for this transfer
      // For each transfer, find the positive and negative quoteParty (amount)
      let qpDebtor = null, qpCreditor = null;
      for (const qp of qps) {
      if (Number(qp.amount) > 0) qpDebtor = qp;
      if (Number(qp.amount) < 0) qpCreditor = qp;
      }
      // Default to using the quoteParty FSP IDs
      let debtorFspId = qpDebtor ? qpDebtor.fspId : undefined;
      let creditorFspId = qpCreditor ? qpCreditor.fspId : undefined;

      // If this transferId is in conversionFspsByTransferIdMap, check if main fspid is a counterparty or initiatingfsp
      const conv = conversionFspsByTransferIdMap[txn.transferId];
      if (conv) {
      // If mainRow's netDebtor or netCreditor FSP ID matches counterPartyFspId or initiatingFspId, do not replace subrow fspid by looking at quoteParties
      // Use participantCurrencyId to get the FSP name
      const mainDebtorPc = allParticipantCurrencyIds.find(pc => pc.participantCurrencyId === mainRow.netDebtor);
      const mainCreditorPc = allParticipantCurrencyIds.find(pc => pc.participantCurrencyId === mainRow.netCreditor);
      const mainDebtorFspId = mainDebtorPc ? mainDebtorPc.name : undefined;
      const mainCreditorFspId = mainCreditorPc ? mainCreditorPc.name : undefined;

      // If mainDebtorFspId matches either, do not update debtorFspId
      if (mainDebtorFspId === conv.counterPartyFspId || mainDebtorFspId === conv.initiatingFspId) {
        debtorFspId = mainDebtorFspId;
      }
      // If mainCreditorFspId matches either, do not update creditorFspId
      if (mainCreditorFspId === conv.counterPartyFspId || mainCreditorFspId === conv.initiatingFspId) {
        creditorFspId = mainCreditorFspId;
      }
      }

      const key = (debtorFspId || '') + '_' + (creditorFspId || '');
      if (!movementMap[key]) {
      movementMap[key] = {
        debtorFspId: debtorFspId,
        creditorFspId: creditorFspId,
        currency: pcCurrency(mainRow.payerParticipantCurrencyDetails) || pcCurrency(mainRow.payeeParticipantCurrencyDetails) || '',
        totalSent: 0,
        totalReceived: 0,
        netSettlement: 0
      };
      }
      // Use the actual settlementParticipantCurrencyIdsResult amounts for totals
      movementMap[key].totalSent += Number(txn.debtorTotalAmount);
      movementMap[key].totalReceived += Number(txn.creditorTotalAmount);
      movementMap[key].netSettlement += Number(txn.debtorTotalAmount) + Number(txn.creditorTotalAmount);
      }
      // Convert to array and enrich with names
      return Object.values(movementMap).map(sub => {
      // Find participant details by FSP ID
      const debtorPc = allParticipantCurrencyIds.find(pc => pc.name === sub.debtorFspId);
      const creditorPc = allParticipantCurrencyIds.find(pc => pc.name === sub.creditorFspId);
      // Try external participant lookup
      const debtorExt = allExternalParticipants.find(ep => ep.externalParticipantName === sub.debtorFspId);
      const creditorExt = allExternalParticipants.find(ep => ep.externalParticipantName === sub.creditorFspId);
      return {
      ...sub,
      debtorName: extName(debtorExt, pcName(debtorPc)) || sub.debtorFspId,
      creditorName: extName(creditorExt, pcName(creditorPc)) || sub.creditorFspId,
      currency: sub.currency
      };
      });
      }

      for (const row of calculatedSettlementRowsWithDetails) {
      const netDebtorName = extName(row.payerExternalParticipant, pcName(row.payerParticipantCurrencyDetails)) || pcName(row.payerParticipantCurrencyDetails);
      const netCreditorName = extName(row.payeeExternalParticipant, pcName(row.payeeParticipantCurrencyDetails)) || pcName(row.payeeParticipantCurrencyDetails);
      const currency = pcCurrency(row.payeeParticipantCurrencyDetails) || pcCurrency(row.payerParticipantCurrencyDetails) || '';
      const totalSent = fmt(row.totalAmountSent);
      const netSettlement = fmt(row.netSettlementAmount);
      %>
      <tr style="font-weight:bold; background:#e9f3fa;">
      <td><%= netDebtorName %></td>
      <td><%= netCreditorName %></td>
      <td><%= currency %></td>
      <td><%= totalSent %></td>
      <td><%= netSettlement %></td>
      <td><%= currency %></td>
      </tr>
      <%
      // Sub-rows: show underlying creditor/debtor FSPs using quoteParty and its amount, but use settlementParticipantCurrencyIdsResult for totals
      const subRows = sumUnderlyingFspMovements(row);
      for (const sub of subRows) {
      const subTotalSent = fmt(sub.totalSent);
      const subNetSettlement = fmt(sub.netSettlement);
      %>
      <tr style="background:#f9f9f9;">
      <td style="padding-left:2em;">&#8627; <%= sub.debtorName %></td>
      <td><%= sub.creditorName %></td>
      <td><%= sub.currency %></td>
      <td><%= subTotalSent %></td>
      <td><%= subNetSettlement %></td>
      <td><%= sub.currency %></td>
      </tr>
      <%
      }
      %>
      <tr><td colspan="6" style="background:#fff; height:8px; border:none;"></td></tr>
      <%
      }
      %>
      </tbody>
      </table>
      </div>

      <div class="footer" style="clear:both; text-align:center; margin-top:40px;">
      <p>Generated on: <%= (new Date()).toUTCString() %></p>
      </div>
      </div>
    </body>

    <div style="margin-top:30px;">
      <button id="toggleTransfersBtn" onclick="toggleTransfersTable()" style="padding:8px 16px; background:#00447c; color:#fff; border:none; border-radius:4px; cursor:pointer;">
        Show Transfers in Settlement
      </button>
    </div>
    <div id="transfersTableContainer" style="display:none; margin-top:20px;">
      <h2 id="transfersHeader" style="margin-top:0;">Transfers in Settlement</h2>
      <table>
        <thead>
          <tr>
            <th>Transfer ID</th>
            <th>Debtor FSP</th>
            <th>Creditor FSP</th>
            <th>Debtor Currency</th>
            <th>Creditor Currency</th>
            <th>Debtor Amount</th>
            <th>Creditor Amount</th>
            <th>Quote ID</th>
            <th>Quote Party Debtor</th>
            <th>Quote Party Creditor</th>
          </tr>
        </thead>
        <tbody>
          <%
            // Helper to get quote party by transferId and amount sign
            function getQuotePartyByAmount(qps, sign) {
              return qps.find(qp => (sign > 0 ? Number(qp.amount) > 0 : Number(qp.amount) < 0));
            }
            for (const txn of settlementParticipantCurrencyIdsResult) {
              const transferId = txn.transferId;
              const debtorPC = allParticipantCurrencyIds.find(pc => pc.participantCurrencyId === txn.debtorParticipantCurrencyId);
              const creditorPC = allParticipantCurrencyIds.find(pc => pc.participantCurrencyId === txn.creditorParticipantCurrencyId);
              const qps = quotePartiesByTransferIdMap[transferId] || [];
              const qpDebtor = getQuotePartyByAmount(qps, 1);
              const qpCreditor = getQuotePartyByAmount(qps, -1);
          %>
          <tr>
            <td><%= transferId %></td>
            <td><%= debtorPC ? debtorPC.name : '' %></td>
            <td><%= creditorPC ? creditorPC.name : '' %></td>
            <td><%= debtorPC ? debtorPC.currencyId : '' %></td>
            <td><%= creditorPC ? creditorPC.currencyId : '' %></td>
            <td><%= fmt(txn.debtorTotalAmount) %></td>
            <td><%= fmt(txn.creditorTotalAmount) %></td>
            <td><%= qpDebtor ? qpDebtor.quoteId : (qpCreditor ? qpCreditor.quoteId : '') %></td>
            <td><%= qpDebtor ? qpDebtor.partyIdentifierValue : '' %></td>
            <td><%= qpCreditor ? qpCreditor.partyIdentifierValue : '' %></td>
          </tr>
          <%
            }
          %>
        </tbody>
      </table>
    </div>
    <script>
        function toggleTransfersTable() {
          var container = document.getElementById('transfersTableContainer');
          var btn = document.getElementById('toggleTransfersBtn');
          var header = document.getElementById('transfersHeader');
          if (container.style.display === 'none') {
        container.style.display = '';
        btn.textContent = 'Hide Transfers in Settlement';
        if (header) header.style.marginTop = '30px';
          } else {
        container.style.display = 'none';
        btn.textContent = 'Show Transfers in Settlement';
        if (header) header.style.marginTop = '0';
          }
        }
    </script>
    </html>
